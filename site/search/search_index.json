{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Build your best UI. Fusion is a modern reactive UI library, built specifically for Roblox and Luau . Build your UI with a declarative syntax that's easy to read and write. Plug in live data with simple, flexible, truly reactive state management. Deliver a fast, smooth experience to everyone - on mobile, console, PC or in VR. Get started Download latest Declarative UI syntax Fusion provides a natural, easy to read syntax, so you can focus on what your UI should look like, without worrying about the implementation. Focus on the properties and children in your UI, not verbose APIs. return New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ) AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function () print ( \"Clicked!\" ) end } } Reactive state management Fluidly write all your calculations, and they'll be intelligently run as your variables change. Fusion brings true granular reactivity from academia to the real world. local numCoins = State ( 10 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) local coinsMessage = Computed ( function () return \"You have \" .. numCoins : get () .. \" coins.\" end ) return New \"TextLabel\" { Text = coinsMessage } Animate everything Bring your UI to life with the simplest, most universal animation tools of any Roblox library. Access tweens and springs with one line of code. Animated data can be processed exactly like any other data. local playerCount = State ( 100 ) local position = State ( UDim2 . new ( 0 , 0 , 0 , 0 )) local smoothCount = Tween ( playerCount , TweenInfo . new ( 0.5 )) return New \"TextLabel\" { Position = Spring ( position , 25 , 0.2 ), Text = Computed ( function () return \"Players online: \" .. math.floor ( smoothCount : get ()) end ) } Fusion is built with performance in mind, from idea to implementation. From top-end desktop PCs to budget phones from years ago, Fusion delivers an exceptionally light, fluid experience for everyone. This ensures your code will scale now and into the future. Even with high-resolution, high-refresh-rate screens coming to low-end devices, all of your UIs will feel fast and stay fast. Get up and running with Fusion in minutes. Downloading and importing Fusion into Studio is quick, easy and 100% free. The Fusion starter tutorials are aimed at a wide range of creators, from seasoned UI developers to novice scripters. /* in the future, I'd like to move this into an external css file somehow */ /* i apologise in advance to anyone who has to maintain this, I've had to do a ton of hacks to get css parallax to work */ html { height: 100%; overflow-y: hidden; scroll-behavior: auto; } html::after { content: ''; position: absolute; top: 100%; left: 0; display: block; width: 100%; height: 100px; z-index: -9999; pointer-events: none; } body { position: absolute; top: 0; left: 0; background-color: var(--md-primary-fg-color); perspective: 1px; perspective-origin: top center; overscroll-behaviour: contain; height: 100%; overflow-x: hidden; overflow-y: auto; } [data-md-color-primary=black] .md-header { background: none; } [data-md-color-primary=black] .md-tabs { background: none; } .fusion-home-landing { min-height: 50rem; font-size: 1.25em; text-align: center; } body::before { content: ''; position: absolute; top: 40rem; left: calc(50% - (116.4rem / 2)); width: 116.4rem; height: 65.475rem; background: url(\"images/index/background2.jpg\"); background-size: 100%; background-repeat: no-repeat; z-index: -10; transform: translateZ(-0.8px) scale(1.8); transform-style: preserve-3d; } .fusion-home-landing h1 { margin-bottom: 0.5em; } .fusion-home-landing p { max-width: 38em; margin: 1em auto; } .fusion-home-landing nav { display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 2em; } .fusion-home-landing a.arrow-link::after { content: \"->\"; display: inline-block; margin-left: 0.25em; margin-right: 0.25em; transition: transform 0.2s ease; } .fusion-home-landing a.arrow-link:hover::after { transform: translateX(0.25em); } .fusion-home-landing .landing-image { margin-top: 3em; margin-bottom: 3em; width: 100%; max-width: 48em; height: auto; } .fusion-home-float { float: left; width: 50%; padding-right: 1rem; } .fusion-home-centre { margin: auto; max-width: 40em; padding-right: 1rem; } /* adding some height to the #learn-more anchor tag means the title of the first section won't be cut off by the page header. */ #learn-more { display: block; width: 1em; height: 3em; } /* HACK: code blocks don't support being floated properly, so they end up taking 100% of the page width, overlapping the paragraph next to them. To fix this, we disable pointer events on the code block directly, but enable it for the children, which are correctly positioned. */ div.highlight { pointer-events: none; } div.highlight * * { pointer-events: initial; } .md-typeset code { background: var(--md-primary-fg-color); } .md-typeset hr { border-bottom-color: var(--md-default-fg-color); opacity: calc(35 / 255); } @media screen and (max-width: 60rem) { .fusion-home-float { float: none; width: 100%; padding: 0rem; } } section h2 { margin-top: 0 !important; } // hack; if the body is scrolled, scroll the html // I'M SO SORRY this is sinful function updateScroll() { if(document.body.scrollTop > 10) { document.documentElement.scrollTop = 100; document.body.style.marginTop = \"100px\"; } else { document.documentElement.scrollTop = 0; document.body.style.marginTop = \"0px\"; } } updateScroll(); document.body.addEventListener(\"scroll\", updateScroll);","title":"Home"},{"location":"api-reference/","text":"API Reference \u00b6 Fusion is a modern reactive UI library, designed and built for Roblox and Luau . Here, you can find documentation for every public API exposed by the Fusion module. Navigation \u00b6 Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page. Commonly Used \u00b6 Jump directly to the documentation for some common APIs: Instances \u00b6 New State Management \u00b6 State Computed ComputedPairs Animation \u00b6 TweenController SpringController","title":"Home"},{"location":"api-reference/#api-reference","text":"Fusion is a modern reactive UI library, designed and built for Roblox and Luau . Here, you can find documentation for every public API exposed by the Fusion module.","title":"API Reference"},{"location":"api-reference/#navigation","text":"Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.","title":"Navigation"},{"location":"api-reference/#commonly-used","text":"Jump directly to the documentation for some common APIs:","title":"Commonly Used"},{"location":"api-reference/#instances","text":"New","title":"Instances"},{"location":"api-reference/#state-management","text":"State Computed ComputedPairs","title":"State Management"},{"location":"api-reference/#animation","text":"TweenController SpringController","title":"Animation"},{"location":"api-reference/errors-and-messages/","text":"If your code isn't working properly, or if Fusion is malfunctioning, you may see some errors being printed to the output. Each message comes with a unique ID at the end. On this page, you can learn more about any error messages you're receiving. computedCallbackError \u00b6 Computed callback error: attempt to index a nil value When you create a new computed object , you can pass in a callback. The callback determines the computed object's value: local example = Computed ( function () -- this is the computed's callback return 2 + 2 end ) If an error is thrown inside of the callback, this message will show with details of the error. Furthermore, if your code attempts to :get() the value of a computed object that errored last time it attempted a computation, the same error will be thrown. If you're seeing this error, consider the following: Is there a bug or unhandled edge case in your callback? Is your computed object using correct, valid data? Are you trying to access data which doesn't exist yet? (for example, trying to index something expected to be a table, but which currently is nil ) Are you calling a function which can error sometimes, but aren't catching the error using pcall ? cannotCreateClass \u00b6 Can't create a new instance of class 'Foo'. Did you spell the class name correctly? When using the New function to construct instances, you're required to pass in a string specifying the class type of the instance: -- this will create a new Folder instance called MyThing local folder = New \"Folder\" { Name = \"MyThing\" } However, if an invalid class type is passed in, then this error will be thrown. If you're seeing this error, consider the following: Did you spell the class name correctly? Are you trying to instantiate a class type which is not creatable? Does your script have the necessary privileges to create that class type? cannotAssignProperty \u00b6 The class type 'Foo' has no assignable property 'Bar'. Did you spell the property name correctly? When using the New function to construct instances, you're able to pass in properties to be assigned to the instance: -- this will create a new Folder instance called MyThing local folder = New \"Folder\" { Name = \"MyThing\" } However, if you attempt to assign a non-existent or locked property, then this error will be thrown. If you're seeing this error, consider the following: Did you spell the property name correctly? Does your script have the necessary privileges to assign that property? strictReadError \u00b6 'Foo' is not a valid member of 'Bar'. Did you spell the member name correctly? In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. If you're seeing this error, consider the following: Did you spell the member name correctly? Are you trying to access a member that doesn't exist? You might encounter this problem after updating Fusion, if you're moving to a version with breaking changes. Make sure to review your code for bugs! eventNotFound \u00b6 The Frame class doesn't have an event called 'Foo'. Did you spell the event name correctly? When using the New function to construct instances, you can register event handlers by using the OnEvent function and passing an event name: -- this will print a message when a user clicks this button local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function () print ( \"I was clicked!\" ) end ) } However, if no event with that name was found, then you'll see this error. If you're seeing this error, consider the following: Did you spell the event name correctly? Are you using a property name instead of an event name? If you want to handle property change events, consider using the Changed event, or registering a property change handler using OnChange . propertyNotFound \u00b6 The Frame class doesn't have a property called 'Foo'. Did you spell the property name correctly? When using the New function to construct instances, you can register property change handlers by using the OnChange function and passing a property name: -- this will print a message when a user types in this text box local button = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end ) } However, if no property with that name was found, then you'll see this error. If you're seeing this error, consider the following: Did you spell the property name correctly? unrecognisedPropertyKey \u00b6 'number' keys aren't accepted in the property table of New . Make sure you're only passing strings or symbols as keys. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" symbol keys, e.g. [OnEvent.Foo] = ... If keys of a different type are present, it's usually not intentional. Fusion will ignore any key/value pairs with unrecognised key types, but will produce this warning to make sure you're aware of the issue. If you're getting this warning, consider the following: Does your property table have an array part? For example: New \"ScreenGui\" { Name = \"Example\" , -- this Frame isn't going to be added as a child! -- it's being added to the array part of the table, and so it'll have a -- number key, which will produce this warning New \"Frame\" { ... } } If you're building the property table at runtime, are you accidentally indexing non-string or non-symbol parts of the table? For example: local propertyTable = {} for key , value in pairs ( someData ) do -- are you sure that `key` is valid here? -- if `someData` was an array, then `key` would be a number! propertyTable [ key ] = value end New \"Part\" ( propertyTable ) unknownMessage \u00b6 Unknown message - the code logging this message didn't provide a valid message ID. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one. If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed.","title":"Errors & Messages"},{"location":"api-reference/errors-and-messages/#computedcallbackerror","text":"Computed callback error: attempt to index a nil value When you create a new computed object , you can pass in a callback. The callback determines the computed object's value: local example = Computed ( function () -- this is the computed's callback return 2 + 2 end ) If an error is thrown inside of the callback, this message will show with details of the error. Furthermore, if your code attempts to :get() the value of a computed object that errored last time it attempted a computation, the same error will be thrown. If you're seeing this error, consider the following: Is there a bug or unhandled edge case in your callback? Is your computed object using correct, valid data? Are you trying to access data which doesn't exist yet? (for example, trying to index something expected to be a table, but which currently is nil ) Are you calling a function which can error sometimes, but aren't catching the error using pcall ?","title":"computedCallbackError"},{"location":"api-reference/errors-and-messages/#cannotcreateclass","text":"Can't create a new instance of class 'Foo'. Did you spell the class name correctly? When using the New function to construct instances, you're required to pass in a string specifying the class type of the instance: -- this will create a new Folder instance called MyThing local folder = New \"Folder\" { Name = \"MyThing\" } However, if an invalid class type is passed in, then this error will be thrown. If you're seeing this error, consider the following: Did you spell the class name correctly? Are you trying to instantiate a class type which is not creatable? Does your script have the necessary privileges to create that class type?","title":"cannotCreateClass"},{"location":"api-reference/errors-and-messages/#cannotassignproperty","text":"The class type 'Foo' has no assignable property 'Bar'. Did you spell the property name correctly? When using the New function to construct instances, you're able to pass in properties to be assigned to the instance: -- this will create a new Folder instance called MyThing local folder = New \"Folder\" { Name = \"MyThing\" } However, if you attempt to assign a non-existent or locked property, then this error will be thrown. If you're seeing this error, consider the following: Did you spell the property name correctly? Does your script have the necessary privileges to assign that property?","title":"cannotAssignProperty"},{"location":"api-reference/errors-and-messages/#strictreaderror","text":"'Foo' is not a valid member of 'Bar'. Did you spell the member name correctly? In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. If you're seeing this error, consider the following: Did you spell the member name correctly? Are you trying to access a member that doesn't exist? You might encounter this problem after updating Fusion, if you're moving to a version with breaking changes. Make sure to review your code for bugs!","title":"strictReadError"},{"location":"api-reference/errors-and-messages/#eventnotfound","text":"The Frame class doesn't have an event called 'Foo'. Did you spell the event name correctly? When using the New function to construct instances, you can register event handlers by using the OnEvent function and passing an event name: -- this will print a message when a user clicks this button local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function () print ( \"I was clicked!\" ) end ) } However, if no event with that name was found, then you'll see this error. If you're seeing this error, consider the following: Did you spell the event name correctly? Are you using a property name instead of an event name? If you want to handle property change events, consider using the Changed event, or registering a property change handler using OnChange .","title":"eventNotFound"},{"location":"api-reference/errors-and-messages/#propertynotfound","text":"The Frame class doesn't have a property called 'Foo'. Did you spell the property name correctly? When using the New function to construct instances, you can register property change handlers by using the OnChange function and passing a property name: -- this will print a message when a user types in this text box local button = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end ) } However, if no property with that name was found, then you'll see this error. If you're seeing this error, consider the following: Did you spell the property name correctly?","title":"propertyNotFound"},{"location":"api-reference/errors-and-messages/#unrecognisedpropertykey","text":"'number' keys aren't accepted in the property table of New . Make sure you're only passing strings or symbols as keys. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" symbol keys, e.g. [OnEvent.Foo] = ... If keys of a different type are present, it's usually not intentional. Fusion will ignore any key/value pairs with unrecognised key types, but will produce this warning to make sure you're aware of the issue. If you're getting this warning, consider the following: Does your property table have an array part? For example: New \"ScreenGui\" { Name = \"Example\" , -- this Frame isn't going to be added as a child! -- it's being added to the array part of the table, and so it'll have a -- number key, which will produce this warning New \"Frame\" { ... } } If you're building the property table at runtime, are you accidentally indexing non-string or non-symbol parts of the table? For example: local propertyTable = {} for key , value in pairs ( someData ) do -- are you sure that `key` is valid here? -- if `someData` was an array, then `key` would be a number! propertyTable [ key ] = value end New \"Part\" ( propertyTable )","title":"unrecognisedPropertyKey"},{"location":"api-reference/errors-and-messages/#unknownmessage","text":"Unknown message - the code logging this message didn't provide a valid message ID. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one. If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed.","title":"unknownMessage"},{"location":"api-reference/luau-types/","text":"Fusion exposes some public Luau types for developers working with strictly typed codebases. These types are exported from the Fusion module directly. In Development Fusion's types are currently in heavy development, and are prone to massive changes. Accordingly, don't depend on these types for production work yet. State<T> \u00b6 An object storing some UI state, such as a state object or a computed object . The generic type T corresponds to the type of value stored in the object. The value of the object can be accessed via a :get() method. local myNumber : State < number > = State ( 5 ) local myMessage : State < string > = Computed ( function () return \"The number is: \" .. myNumber : get () end ) StateOrValue<T> \u00b6 Represents either a variable of type T , or some UI state of type T . This is equivalent to State<T> | T . local function accept ( item : StateOrValue < string > ) if typeof ( item ) == \"string\" then -- variable of type string print ( \"variable:\" , item ) else -- state/computed object containing a string print ( \"state/computed object:\" , item : get ()) end end accept ( \"Hello\" ) accept ( State ( \"World\" )) accept ( Computed ( \"Goodbye\" )) Symbol \u00b6 Represents a named symbol. Symbols are named constants which carry special meaning. In Fusion, symbols are commonly used for special keys, such as Children or OnEvent . local example : Symbol = Fusion . Children","title":"Luau Types"},{"location":"api-reference/luau-types/#statet","text":"An object storing some UI state, such as a state object or a computed object . The generic type T corresponds to the type of value stored in the object. The value of the object can be accessed via a :get() method. local myNumber : State < number > = State ( 5 ) local myMessage : State < string > = Computed ( function () return \"The number is: \" .. myNumber : get () end )","title":"State&lt;T&gt;"},{"location":"api-reference/luau-types/#stateorvaluet","text":"Represents either a variable of type T , or some UI state of type T . This is equivalent to State<T> | T . local function accept ( item : StateOrValue < string > ) if typeof ( item ) == \"string\" then -- variable of type string print ( \"variable:\" , item ) else -- state/computed object containing a string print ( \"state/computed object:\" , item : get ()) end end accept ( \"Hello\" ) accept ( State ( \"World\" )) accept ( Computed ( \"Goodbye\" ))","title":"StateOrValue&lt;T&gt;"},{"location":"api-reference/luau-types/#symbol","text":"Represents a named symbol. Symbols are named constants which carry special meaning. In Fusion, symbols are commonly used for special keys, such as Children or OnEvent . local example : Symbol = Fusion . Children","title":"Symbol"},{"location":"api-reference/api/computed/","text":"Fusion.computed Todo Link to the state tutorial in the Basics section when it's done function computed ( callback : () -> any ) : Computed Constructs and returns a reactive state object, using a computation to define its value. The value returned from the callback is used when recomputing the value stored by this object. The callback becomes a reactive context; getting the value of a state object while inside the callback will add that state object as a dependency. If that state object then changes its value, it will cause this object to recompute its value. Overview \u00b6 State objects are the fundamental building block of Fusion's state management system. They hold a single value - much like a variable - and this value can be set or got at any time. -- creating a state object -- you can give it an initial value here - in this case, 2 local number = state ( 2 ) -- get the value and print it print ( number : get ()) --> 2 -- set the value to 5 number : set ( 5 ) -- short syntax for getting the value -- this is the preferred way of getting the value print ( number ()) --> 5 The key feature of state objects is that they're observable ; when a script sets the value of a state object, other scripts can be notified and respond to the change immediately. Fusion lets you tap into that feature in your own scripts using computeds and effects . While inside the callback of a computed or effect, Fusion will keep track of which state objects you get the value of. Then, it'll listen for changes in any of those state objects. If any of them change, the callback will be run again. -- this counter will increase over time -- it's important to keep any non-constant values in state objects local counter = state ( 0 ) -- Fusion will run this calculation every time `counter` changes local counterPlusOne = computed ( function () return counter () + 1 end ) -- Fusion will run this function every time `counterPlusOne` changes effect ( function () print ( counterPlusOne ()) end ) For a more comprehensive overview of state management within Fusion, visit the state management tutorial. Object Methods \u00b6 get() \u00b6 function State : get () : any Returns the value currently stored in this state object. If used inside a reactive context (e.g. in an computed's callback), this state object is added as a dependency. Tip While this method can be called directly, it's conventionally preferred to call the state object itself to get the value instead: local counter = state ( 5 ) -- normal syntax print ( state : get ()) --> 5 -- short syntax (preferred) print ( state ()) --> 5 Using this shorter syntax often leads to much cleaner and easier to read code. This method is mainly exposed as a fallback for when the shorter syntax may not be suitable (for example, if the shorter syntax causes trouble with strict typed Luau). set() \u00b6 function State : set ( newValue : any ) Stores the given value in this state object. If the new value is different from the old value, and other reactive objects depend on this state object, then they will be notified of the change in topological order. See Also \u00b6 computed() effect()","title":"Computed"},{"location":"api-reference/api/computed/#overview","text":"State objects are the fundamental building block of Fusion's state management system. They hold a single value - much like a variable - and this value can be set or got at any time. -- creating a state object -- you can give it an initial value here - in this case, 2 local number = state ( 2 ) -- get the value and print it print ( number : get ()) --> 2 -- set the value to 5 number : set ( 5 ) -- short syntax for getting the value -- this is the preferred way of getting the value print ( number ()) --> 5 The key feature of state objects is that they're observable ; when a script sets the value of a state object, other scripts can be notified and respond to the change immediately. Fusion lets you tap into that feature in your own scripts using computeds and effects . While inside the callback of a computed or effect, Fusion will keep track of which state objects you get the value of. Then, it'll listen for changes in any of those state objects. If any of them change, the callback will be run again. -- this counter will increase over time -- it's important to keep any non-constant values in state objects local counter = state ( 0 ) -- Fusion will run this calculation every time `counter` changes local counterPlusOne = computed ( function () return counter () + 1 end ) -- Fusion will run this function every time `counterPlusOne` changes effect ( function () print ( counterPlusOne ()) end ) For a more comprehensive overview of state management within Fusion, visit the state management tutorial.","title":"Overview"},{"location":"api-reference/api/computed/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/computed/#get","text":"function State : get () : any Returns the value currently stored in this state object. If used inside a reactive context (e.g. in an computed's callback), this state object is added as a dependency. Tip While this method can be called directly, it's conventionally preferred to call the state object itself to get the value instead: local counter = state ( 5 ) -- normal syntax print ( state : get ()) --> 5 -- short syntax (preferred) print ( state ()) --> 5 Using this shorter syntax often leads to much cleaner and easier to read code. This method is mainly exposed as a fallback for when the shorter syntax may not be suitable (for example, if the shorter syntax causes trouble with strict typed Luau).","title":"get()"},{"location":"api-reference/api/computed/#set","text":"function State : set ( newValue : any ) Stores the given value in this state object. If the new value is different from the old value, and other reactive objects depend on this state object, then they will be notified of the change in topological order.","title":"set()"},{"location":"api-reference/api/computed/#see-also","text":"computed() effect()","title":"See Also"},{"location":"api-reference/api/state/","text":"Fusion.state Todo Link to the state tutorial in the Basics section when it's done function state ( initialValue : any ) : State Constructs and returns a reactive state object, with a value that can be set and got. If an initialValue is specified, the state object will be initialised storing that value. Overview \u00b6 State objects are the fundamental building block of Fusion's state management system. They hold a single value - much like a variable - and this value can be set or got at any time. -- creating a state object -- you can give it an initial value here - in this case, 2 local number = state ( 2 ) -- get the value and print it print ( number : get ()) --> 2 -- set the value to 5 number : set ( 5 ) -- short syntax for getting the value -- this is the preferred way of getting the value print ( number ()) --> 5 The key feature of state objects is that they're observable ; when a script sets the value of a state object, other scripts can be notified and respond to the change immediately. Fusion lets you tap into that feature in your own scripts using computeds and effects . While inside the callback of a computed or effect, Fusion will keep track of which state objects you get the value of. Then, it'll listen for changes in any of those state objects. If any of them change, the callback will be run again. -- this counter will increase over time -- it's important to keep any non-constant values in state objects local counter = state ( 0 ) -- Fusion will run this calculation every time `counter` changes local counterPlusOne = computed ( function () return counter () + 1 end ) -- Fusion will run this function every time `counterPlusOne` changes effect ( function () print ( counterPlusOne ()) end ) For a more comprehensive overview of state management within Fusion, visit the state management tutorial. Object Methods \u00b6 get() \u00b6 function State : get () : any Returns the value currently stored in this state object. If used in a reactive context (e.g. in an computed's callback), this state object is added as a dependency. Tip While this method can be called directly, it's conventionally preferred to call the state object itself to get the value instead: local counter = state ( 5 ) -- normal syntax print ( state : get ()) --> 5 -- short syntax (preferred) print ( state ()) --> 5 Using this shorter syntax often leads to much cleaner and easier to read code. This method is mainly exposed as a fallback for when the shorter syntax may not be suitable (for example, if the shorter syntax causes trouble with strict typed Luau). set() \u00b6 function State : set ( newValue : any ) Stores the given value in this state object. If the new value is different from the old value, and other reactive objects depend on this state object, then they will be notified of the change in topological order. See Also \u00b6 computed() effect()","title":"State"},{"location":"api-reference/api/state/#overview","text":"State objects are the fundamental building block of Fusion's state management system. They hold a single value - much like a variable - and this value can be set or got at any time. -- creating a state object -- you can give it an initial value here - in this case, 2 local number = state ( 2 ) -- get the value and print it print ( number : get ()) --> 2 -- set the value to 5 number : set ( 5 ) -- short syntax for getting the value -- this is the preferred way of getting the value print ( number ()) --> 5 The key feature of state objects is that they're observable ; when a script sets the value of a state object, other scripts can be notified and respond to the change immediately. Fusion lets you tap into that feature in your own scripts using computeds and effects . While inside the callback of a computed or effect, Fusion will keep track of which state objects you get the value of. Then, it'll listen for changes in any of those state objects. If any of them change, the callback will be run again. -- this counter will increase over time -- it's important to keep any non-constant values in state objects local counter = state ( 0 ) -- Fusion will run this calculation every time `counter` changes local counterPlusOne = computed ( function () return counter () + 1 end ) -- Fusion will run this function every time `counterPlusOne` changes effect ( function () print ( counterPlusOne ()) end ) For a more comprehensive overview of state management within Fusion, visit the state management tutorial.","title":"Overview"},{"location":"api-reference/api/state/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/state/#get","text":"function State : get () : any Returns the value currently stored in this state object. If used in a reactive context (e.g. in an computed's callback), this state object is added as a dependency. Tip While this method can be called directly, it's conventionally preferred to call the state object itself to get the value instead: local counter = state ( 5 ) -- normal syntax print ( state : get ()) --> 5 -- short syntax (preferred) print ( state ()) --> 5 Using this shorter syntax often leads to much cleaner and easier to read code. This method is mainly exposed as a fallback for when the shorter syntax may not be suitable (for example, if the shorter syntax causes trouble with strict typed Luau).","title":"get()"},{"location":"api-reference/api/state/#set","text":"function State : set ( newValue : any ) Stores the given value in this state object. If the new value is different from the old value, and other reactive objects depend on this state object, then they will be notified of the change in topological order.","title":"set()"},{"location":"api-reference/api/state/#see-also","text":"computed() effect()","title":"See Also"},{"location":"tutorials/","text":"Welcome to the Fusion tutorial section! Here, you'll learn how to build great interfaces with Fusion, even if you're a complete newcomer to the library. What You Need To Know \u00b6 These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged \ud83d\ude42 How These Tutorials Work \u00b6 You can find the tutorials in the navigation bar to your left. Tutorials are grouped together by category, and are designed to explore specific features of Fusion. You can either do them in order (recommended for newcomers), or you can jump to a specific tutorial for a quick refresh. You'll also see 'projects' at regular intervals, which combine concepts from earlier tutorials and show how they interact and work together in a real setting. At the beginning of every tutorial, you'll see a section titled 'Required code'. They look like this - you can click to expand them: Required code 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) Before starting each tutorial, make sure to copy the code into your script editor, so you can follow along properly. Similarly, you'll find the finished code for the tutorial at the end, under 'Finished code': Finished code 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) print ( \"Pretend we added some code during the tutorial here...\" ) You can use the finished code as a reference if you get stuck - it'll contain the script as it appears after following all the steps of the tutorial. Installing Fusion \u00b6 Fusion is distributed as a single ModuleScript . Before starting, you'll need to add this module script to your game. Here's how: Fusion for Roblox Studio \u00b6 If you script in Roblox Studio, here's how to install Fusion: Steps Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .rbxm file to download it. This contains the Fusion module script. In Roblox Studio, open or create a place. Right-click on ReplicatedStorage, and select 'Insert from File'. Find the .rbxm you just downloaded, and select it. You should now see a ModuleScript called 'Fusion' sitting in ReplicatedStorage - you're ready to go! Fusion for External Editors \u00b6 If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, here's how to install Fusion: Steps (click to expand) Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .zip file to download it. Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be in a nested folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project. Setting Up A Test Script \u00b6 Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in a service like StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note This code assumes you've installed Fusion into ReplicatedStorage. If you've installed Fusion elsewhere, you'll need to tweak the require() to point to the correct location. If everything was set up correctly, you can press 'Play' and everything should run without any errors. My script doesn't work - common errors Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. Refer back to the previous section and double-check you've set everything up properly. If you're using the installation guide from above, your ReplicatedStorage should look like this:","title":"Get Started"},{"location":"tutorials/#what-you-need-to-know","text":"These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged \ud83d\ude42","title":"What You Need To Know"},{"location":"tutorials/#how-these-tutorials-work","text":"You can find the tutorials in the navigation bar to your left. Tutorials are grouped together by category, and are designed to explore specific features of Fusion. You can either do them in order (recommended for newcomers), or you can jump to a specific tutorial for a quick refresh. You'll also see 'projects' at regular intervals, which combine concepts from earlier tutorials and show how they interact and work together in a real setting. At the beginning of every tutorial, you'll see a section titled 'Required code'. They look like this - you can click to expand them: Required code 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) Before starting each tutorial, make sure to copy the code into your script editor, so you can follow along properly. Similarly, you'll find the finished code for the tutorial at the end, under 'Finished code': Finished code 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) print ( \"Pretend we added some code during the tutorial here...\" ) You can use the finished code as a reference if you get stuck - it'll contain the script as it appears after following all the steps of the tutorial.","title":"How These Tutorials Work"},{"location":"tutorials/#installing-fusion","text":"Fusion is distributed as a single ModuleScript . Before starting, you'll need to add this module script to your game. Here's how:","title":"Installing Fusion"},{"location":"tutorials/#fusion-for-roblox-studio","text":"If you script in Roblox Studio, here's how to install Fusion: Steps Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .rbxm file to download it. This contains the Fusion module script. In Roblox Studio, open or create a place. Right-click on ReplicatedStorage, and select 'Insert from File'. Find the .rbxm you just downloaded, and select it. You should now see a ModuleScript called 'Fusion' sitting in ReplicatedStorage - you're ready to go!","title":"Fusion for Roblox Studio"},{"location":"tutorials/#fusion-for-external-editors","text":"If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, here's how to install Fusion: Steps (click to expand) Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .zip file to download it. Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be in a nested folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project.","title":"Fusion for External Editors"},{"location":"tutorials/#setting-up-a-test-script","text":"Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in a service like StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note This code assumes you've installed Fusion into ReplicatedStorage. If you've installed Fusion elsewhere, you'll need to tweak the require() to point to the correct location. If everything was set up correctly, you can press 'Play' and everything should run without any errors. My script doesn't work - common errors Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. Refer back to the previous section and double-check you've set everything up properly. If you're using the installation guide from above, your ReplicatedStorage should look like this:","title":"Setting Up A Test Script"},{"location":"tutorials/project-1-counting-clicks/","text":"You've learned how UIs work with New , and you've seen how state management works with State and Computed . Ready to fuse them into one unified script? Where We Left Off \u00b6 We're going to be returning to our first LocalScript for this tutorial - it's okay to delete the script from last time if you're done with it. For reference, here's where we left off: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextBox\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } Before we get started, we need to import State and Computed , so we can use it later: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local New = Fusion . New Awesome - we're ready to begin. Building A Counting Button \u00b6 We're going to modify our script to create a simple counting button. Every time we click the button, it'll show how many times we've clicked it so far. Firstly, let's switch out our TextBox for a TextButton, and clean out some old properties we don't need anymore. Don't worry about the Text property for now - we'll come back to that later. 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ) } } Next, we'll set up an event handler, to detect when the user clicks our button: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () --TODO: count clicks end } } Now, we need to introduce some state to our script. Just above our UI code, we'll add a counter state object, which will store how many clicks the button has recieved: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () --TODO: count clicks end } } Now, back in our event handler, we can increment the counter on every click by getting the value of counter , adding 1, then setting the value again: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } Cool - we can now count clicks! Linking Instances And State \u00b6 Our last problem is displaying a message. How do we dynamically set the Text property on our TextButton? The answer is stunningly simple. New has yet another trick up its sleeve - you can set a property to a State or Computed, and it'll just work. Let's try it: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = counter , [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } No messing around with updating properties manually or anything! Try it out by pressing 'Play' - click the button a few times, and the text will update in real time: This is fantastic, but that number looks a bit lonely. How could we add some extra text? That's also simple to do - we'll just make the Text property derive from counter using a Computed object: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () if counter : get () == 0 then return \"Click me!\" else return \"You've clicked \" .. counter : get () .. \" time(s).\" end end ), [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } Just like magic, our number now has some much-needed context! If you've reached this point, congratulations! You now know the fundamentals of building UI and managing state using Fusion, and you're ready to move on to higher-level concepts and tutorials. While you're here, though, why not play around with your button for a bit? See if you can make it look nicer; feel free to dabble with adding extra instances such as UIStroke or UICorner:","title":"Project 1: Counting Clicks"},{"location":"tutorials/project-1-counting-clicks/#where-we-left-off","text":"We're going to be returning to our first LocalScript for this tutorial - it's okay to delete the script from last time if you're done with it. For reference, here's where we left off: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextBox\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } Before we get started, we need to import State and Computed , so we can use it later: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local New = Fusion . New Awesome - we're ready to begin.","title":"Where We Left Off"},{"location":"tutorials/project-1-counting-clicks/#building-a-counting-button","text":"We're going to modify our script to create a simple counting button. Every time we click the button, it'll show how many times we've clicked it so far. Firstly, let's switch out our TextBox for a TextButton, and clean out some old properties we don't need anymore. Don't worry about the Text property for now - we'll come back to that later. 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ) } } Next, we'll set up an event handler, to detect when the user clicks our button: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () --TODO: count clicks end } } Now, we need to introduce some state to our script. Just above our UI code, we'll add a counter state object, which will store how many clicks the button has recieved: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () --TODO: count clicks end } } Now, back in our event handler, we can increment the counter on every click by getting the value of counter , adding 1, then setting the value again: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } Cool - we can now count clicks!","title":"Building A Counting Button"},{"location":"tutorials/project-1-counting-clicks/#linking-instances-and-state","text":"Our last problem is displaying a message. How do we dynamically set the Text property on our TextButton? The answer is stunningly simple. New has yet another trick up its sleeve - you can set a property to a State or Computed, and it'll just work. Let's try it: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = counter , [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } No messing around with updating properties manually or anything! Try it out by pressing 'Play' - click the button a few times, and the text will update in real time: This is fantastic, but that number looks a bit lonely. How could we add some extra text? That's also simple to do - we'll just make the Text property derive from counter using a Computed object: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 local counter = State ( 0 ) local gui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = Enum . ZIndexBehavior . Sibling , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () if counter : get () == 0 then return \"Click me!\" else return \"You've clicked \" .. counter : get () .. \" time(s).\" end end ), [ OnEvent \"Activated\" ] = function () counter : set ( counter : get () + 1 ) end } } Just like magic, our number now has some much-needed context! If you've reached this point, congratulations! You now know the fundamentals of building UI and managing state using Fusion, and you're ready to move on to higher-level concepts and tutorials. While you're here, though, why not play around with your button for a bit? See if you can make it look nicer; feel free to dabble with adding extra instances such as UIStroke or UICorner:","title":"Linking Instances And State"},{"location":"tutorials/basic-state/computations/","text":"Often, we don't use raw values directly in our UI; instead, we need to perform computations on those values. Let's learn how to compute new values from existing ones. Required code 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local numPlayers = State ( 5 ) The Computation Problem \u00b6 In UI development, lots of values are computed based on other values. For example, you might compute a message based on the number of players online: local numPlayers = 5 local message = \"There are \" .. numPlayers .. \" players online.\" However, there's a problem - when numPlayers changes, we have to manually re-calculate the message value ourselves. If you don't, then the message will show the wrong amount of players - an issue known as 'data desynchronisation'. This very same problem appears with Fusion's state objects - after all, they behave much the same as variables do. We can cause a data desynchronisation bug by changing the number of players without also changing the message: Lua local numPlayers = State ( 5 ) local message = State ( \"There are \" .. numPlayers : get () .. \" players online.\" ) print ( \"Num players:\" , numPlayers : get ()) print ( \"Message:\" , message : get ()) numPlayers : set ( 12 ) print ( \"Num players:\" , numPlayers : get ()) print ( \"Message:\" , message : get ()) Expected output Num players: 5 Message: There are 5 players online. Num players: 12 Message: There are 5 players online. Computed Objects \u00b6 To solve this problem, Fusion introduces a second kind of object - 'computed objects' . Instead of storing a fixed value, they run a given computation to find the value. To use computed objects, we first need to import the Computed constructor: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Now, we can create a computed object by calling the constructor. We pass in our computation as a function: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) At any time, you can get the computed value with the :get() method: Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) Expected output There are 5 players online. If you're using other state (or computed) objects in your computation, then the value will update automatically as those other objects change: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. There are 12 players online. With that, you understand the basic idea of computed objects! They let you define your values reactively - as automatically-updating computations. Danger Stick to using state objects and computed objects inside your computations. Fusion can detect these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables, or get values from 'normal' functions: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object when the variable changes: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' Listening for Changes \u00b6 You can listen for changes using the onChange event, which will fire every time the computed object updates its value: Lua 7 8 9 10 11 12 13 14 15 16 17 18 19 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. The message was changed! There are 12 players online. If you'd like to disconnect from the event later, :Connect() returns a function which, when called, will disconnect your event handler: Lua 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) disconnect () numPlayers : set ( 0 ) print ( message : get ()) Expected output There are 5 players online. The message was changed! There are 12 players online. There are 0 players online. Why Computed Objects? \u00b6 This section contains optional, extra knowledge This section is mainly for people who are curious about why exactly computed objects are used in Fusion. You don't have to know this if you just want to use computed objects. Looking at a computed object, it might look similar to a function in nature. You might be wondering why we don't just use functions for computations like this. It's true that in simple examples, you wouldn't notice any difference between an object-based and function-based approach: local numPlayers = State ( 5 ) local function getMessage () return \"There are \" .. numPlayers : get () .. \" players online.\" end This function seems to have all the desirable properties of a computed object - it won't have any data desynchronisation issues, for example: Lua local numPlayers = State ( 5 ) local function getMessage () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( getMessage ()) numPlayers : set ( 12 ) print ( getMessage ()) Expected output There are 5 players online. There are 12 players online. However, there's fundamentally a problem with this approach - we don't know when this function's value changes. It could change at any time, based on any variables, for any reason. The behaviour of the function is unpredictable. This makes it difficult to optimise - if we wanted to set some text label's Text property so it matches a function, for example, we'd have to poll the function's value every single frame, just to check if the value changed. This is extremely bad for performance. One simple solution to this problem is to provide a 'changed' event alongside the function, and fire the event whenever the function has changed it's value. This solves the above problem nicely, and allows us to perform caching to further improve performance. It turns out that this is actually where computed objects originally came from - conceptually, they're just a function with a changed event attached! The only difference is that it's all wrapped up nicely in an object-oriented API, so you don't have to worry about those details. From there, the only difference to 'real' computed objects is all of the extra features Fusion provides to make these objects easier to write and optimise, for example automatically detecting which state objects you're using, and updating your objects for you. Now, we've covered everything we need to know about Fusion's basic state tools. Using computed objects and state objects together, you can easily store and compute values while avoiding data desynchronisation bugs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) disconnect () numPlayers : set ( 0 ) print ( message : get ())","title":"Computations"},{"location":"tutorials/basic-state/computations/#the-computation-problem","text":"In UI development, lots of values are computed based on other values. For example, you might compute a message based on the number of players online: local numPlayers = 5 local message = \"There are \" .. numPlayers .. \" players online.\" However, there's a problem - when numPlayers changes, we have to manually re-calculate the message value ourselves. If you don't, then the message will show the wrong amount of players - an issue known as 'data desynchronisation'. This very same problem appears with Fusion's state objects - after all, they behave much the same as variables do. We can cause a data desynchronisation bug by changing the number of players without also changing the message: Lua local numPlayers = State ( 5 ) local message = State ( \"There are \" .. numPlayers : get () .. \" players online.\" ) print ( \"Num players:\" , numPlayers : get ()) print ( \"Message:\" , message : get ()) numPlayers : set ( 12 ) print ( \"Num players:\" , numPlayers : get ()) print ( \"Message:\" , message : get ()) Expected output Num players: 5 Message: There are 5 players online. Num players: 12 Message: There are 5 players online.","title":"The Computation Problem"},{"location":"tutorials/basic-state/computations/#computed-objects","text":"To solve this problem, Fusion introduces a second kind of object - 'computed objects' . Instead of storing a fixed value, they run a given computation to find the value. To use computed objects, we first need to import the Computed constructor: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Now, we can create a computed object by calling the constructor. We pass in our computation as a function: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) At any time, you can get the computed value with the :get() method: Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) Expected output There are 5 players online. If you're using other state (or computed) objects in your computation, then the value will update automatically as those other objects change: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. There are 12 players online. With that, you understand the basic idea of computed objects! They let you define your values reactively - as automatically-updating computations. Danger Stick to using state objects and computed objects inside your computations. Fusion can detect these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables, or get values from 'normal' functions: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object when the variable changes: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World'","title":"Computed Objects"},{"location":"tutorials/basic-state/computations/#listening-for-changes","text":"You can listen for changes using the onChange event, which will fire every time the computed object updates its value: Lua 7 8 9 10 11 12 13 14 15 16 17 18 19 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. The message was changed! There are 12 players online. If you'd like to disconnect from the event later, :Connect() returns a function which, when called, will disconnect your event handler: Lua 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) disconnect () numPlayers : set ( 0 ) print ( message : get ()) Expected output There are 5 players online. The message was changed! There are 12 players online. There are 0 players online.","title":"Listening for Changes"},{"location":"tutorials/basic-state/computations/#why-computed-objects","text":"This section contains optional, extra knowledge This section is mainly for people who are curious about why exactly computed objects are used in Fusion. You don't have to know this if you just want to use computed objects. Looking at a computed object, it might look similar to a function in nature. You might be wondering why we don't just use functions for computations like this. It's true that in simple examples, you wouldn't notice any difference between an object-based and function-based approach: local numPlayers = State ( 5 ) local function getMessage () return \"There are \" .. numPlayers : get () .. \" players online.\" end This function seems to have all the desirable properties of a computed object - it won't have any data desynchronisation issues, for example: Lua local numPlayers = State ( 5 ) local function getMessage () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( getMessage ()) numPlayers : set ( 12 ) print ( getMessage ()) Expected output There are 5 players online. There are 12 players online. However, there's fundamentally a problem with this approach - we don't know when this function's value changes. It could change at any time, based on any variables, for any reason. The behaviour of the function is unpredictable. This makes it difficult to optimise - if we wanted to set some text label's Text property so it matches a function, for example, we'd have to poll the function's value every single frame, just to check if the value changed. This is extremely bad for performance. One simple solution to this problem is to provide a 'changed' event alongside the function, and fire the event whenever the function has changed it's value. This solves the above problem nicely, and allows us to perform caching to further improve performance. It turns out that this is actually where computed objects originally came from - conceptually, they're just a function with a changed event attached! The only difference is that it's all wrapped up nicely in an object-oriented API, so you don't have to worry about those details. From there, the only difference to 'real' computed objects is all of the extra features Fusion provides to make these objects easier to write and optimise, for example automatically detecting which state objects you're using, and updating your objects for you. Now, we've covered everything we need to know about Fusion's basic state tools. Using computed objects and state objects together, you can easily store and compute values while avoiding data desynchronisation bugs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) numPlayers : set ( 12 ) print ( message : get ()) disconnect () numPlayers : set ( 0 ) print ( message : get ())","title":"Why Computed Objects?"},{"location":"tutorials/basic-state/state-objects/","text":"UI often depends on data being updated over time, for example round timers and money counters. Let's learn how to store simple values that change over time. Required code 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Storing Single Values \u00b6 Fusion has multiple tools for dealing with 'state' - the pieces of data that change over time in your UI. The simplest is the State object, an OOP object that stores a single value. To use state objects, we first need to import the State constructor: 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Now, we can create a state object by calling the constructor. If you pass in a value, it'll be stored inside the state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) At any time, you can get the currently stored value with the :get() method: Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) Expected output The value is: Hello You can also set the value by calling :set() with a new value: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The new value is: World That's the basic idea of state objects - they're kind of like variables, but in object form. Listening for Changes \u00b6 You can listen for changes using the onChange event, which will fire every time a new value is stored in the state object: Lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The message was changed! The new value is: World If you'd like to disconnect from the event later, :Connect() returns a function which, when called, will disconnect your event handler: Lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) disconnect () message : set ( \"Sneaky\" ) print ( \"The final value is:\" , message : get ()) Expected output The value is: Hello The message was changed! The new value is: World The final value is: Sneaky Why State Objects? \u00b6 This section contains optional, extra knowledge This section is mainly for people who are curious about why exactly state objects are used in Fusion. You don't have to know this if you just want to use state objects. In an ideal world, we would be able to refer to variables in our UI code, for example: -- the number of coins the player has local myCoins = 10 -- ideally, this would make the text match the number of coins the player has local counter = New \"TextLabel\" { Text = myCoins } -- later on, if the number of coins changes, we would like the text to update! wait ( 5 ) myCoins = 25 Unfortunately, this doesn't work. When we type Text = myCoins , Lua is copying the value of myCoins into Text . This means, when we change the value of myCoins later, our text is unaffected. Objects in Lua don't have this limitation - Lua never copies objects in this way: local function modify ( variable , object ) -- variables are *copied*, so we're only modifying the copy variable += 1 -- objects are *not copied*, so this modifies the actual object object . value += 1 end -- make a variable and an object, both storing 1 local variable = 1 local object = { value = 1 } -- try to pass our variable and our object somewhere else modify ( variable , object ) -- notice the object is modified, but the variable is not print ( variable ) --> 1 print ( object . value ) --> 2 This means we can pass state objects around, and any code using the state object can see the correct value at all times: Lua local myMessage = State ( \"Hello\" ) local function logValueOf ( stateObject ) -- run a loop to print the value of the state object over time spawn ( function () while true do print ( stateObject : get ()) wait ( 1 ) end end ) end logValueOf ( myMessage ) wait ( 2.5 ) myMessage : set ( \"World\" ) Expected output Hello Hello Hello World World (etc) This makes our original example (involving the text label) possible, because the value isn't copied anymore: -- the number of coins the player has local myCoins = State ( 10 ) -- this makes the text match the number of coins the player has local counter = New \"TextLabel\" { Text = myCoins } -- later on, if the number of coins changes, the text will update! wait ( 5 ) myCoins : set ( 25 ) Thanks to state objects, we can pass in myCoins , and Fusion can see the correct value at all times. We'll explore this specific example in a future tutorial in more detail, when we talk about linking UI and state. With that, you should now have a basic idea of what state objects can do - they're the simplest and most fundamental tool Fusion offers for managing state. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) disconnect () message : set ( \"Sneaky\" ) print ( \"The final value is:\" , message : get ())","title":"State Objects"},{"location":"tutorials/basic-state/state-objects/#storing-single-values","text":"Fusion has multiple tools for dealing with 'state' - the pieces of data that change over time in your UI. The simplest is the State object, an OOP object that stores a single value. To use state objects, we first need to import the State constructor: 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Now, we can create a state object by calling the constructor. If you pass in a value, it'll be stored inside the state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) At any time, you can get the currently stored value with the :get() method: Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) Expected output The value is: Hello You can also set the value by calling :set() with a new value: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The new value is: World That's the basic idea of state objects - they're kind of like variables, but in object form.","title":"Storing Single Values"},{"location":"tutorials/basic-state/state-objects/#listening-for-changes","text":"You can listen for changes using the onChange event, which will fire every time a new value is stored in the state object: Lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The message was changed! The new value is: World If you'd like to disconnect from the event later, :Connect() returns a function which, when called, will disconnect your event handler: Lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) disconnect () message : set ( \"Sneaky\" ) print ( \"The final value is:\" , message : get ()) Expected output The value is: Hello The message was changed! The new value is: World The final value is: Sneaky","title":"Listening for Changes"},{"location":"tutorials/basic-state/state-objects/#why-state-objects","text":"This section contains optional, extra knowledge This section is mainly for people who are curious about why exactly state objects are used in Fusion. You don't have to know this if you just want to use state objects. In an ideal world, we would be able to refer to variables in our UI code, for example: -- the number of coins the player has local myCoins = 10 -- ideally, this would make the text match the number of coins the player has local counter = New \"TextLabel\" { Text = myCoins } -- later on, if the number of coins changes, we would like the text to update! wait ( 5 ) myCoins = 25 Unfortunately, this doesn't work. When we type Text = myCoins , Lua is copying the value of myCoins into Text . This means, when we change the value of myCoins later, our text is unaffected. Objects in Lua don't have this limitation - Lua never copies objects in this way: local function modify ( variable , object ) -- variables are *copied*, so we're only modifying the copy variable += 1 -- objects are *not copied*, so this modifies the actual object object . value += 1 end -- make a variable and an object, both storing 1 local variable = 1 local object = { value = 1 } -- try to pass our variable and our object somewhere else modify ( variable , object ) -- notice the object is modified, but the variable is not print ( variable ) --> 1 print ( object . value ) --> 2 This means we can pass state objects around, and any code using the state object can see the correct value at all times: Lua local myMessage = State ( \"Hello\" ) local function logValueOf ( stateObject ) -- run a loop to print the value of the state object over time spawn ( function () while true do print ( stateObject : get ()) wait ( 1 ) end end ) end logValueOf ( myMessage ) wait ( 2.5 ) myMessage : set ( \"World\" ) Expected output Hello Hello Hello World World (etc) This makes our original example (involving the text label) possible, because the value isn't copied anymore: -- the number of coins the player has local myCoins = State ( 10 ) -- this makes the text match the number of coins the player has local counter = New \"TextLabel\" { Text = myCoins } -- later on, if the number of coins changes, the text will update! wait ( 5 ) myCoins : set ( 25 ) Thanks to state objects, we can pass in myCoins , and Fusion can see the correct value at all times. We'll explore this specific example in a future tutorial in more detail, when we talk about linking UI and state. With that, you should now have a basic idea of what state objects can do - they're the simplest and most fundamental tool Fusion offers for managing state. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) local disconnect = message . onChange : Connect ( function () print ( \"The message was changed!\" ) end ) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) disconnect () message : set ( \"Sneaky\" ) print ( \"The final value is:\" , message : get ())","title":"Why State Objects?"},{"location":"tutorials/instances/handling-events/","text":"Since we can create instances, we should also be able to listen for events and user inputs. Let's learn how you can do this with the New function. Required code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false } } } Connecting to Events \u00b6 Inside the code from above, you'll notice a TextButton. Let's try to connect to it's Activated event to detect mouse clicks. To help with this, New allows us to add event handlers on our instance directly. In order to use this feature, we need to import OnEvent from Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Now you can pass in event handling functions by using [ OnEvent \"EventName\" ] as the key. As an example, here we're connecting a function to our TextButton's Activated event: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), This works just like a regular :Connect - you'll recieve all the arguments from the event. Here, we're just printing them out for demonstration purposes. If you press 'Play' and click the button a few times, you should see something like this in the output: That's all there is to event handling! Fusion will manage the event connections for you automatically. Responding to Change \u00b6 In addition to regular events, you can listen to property change events (also known as: the events returned by GetPropertyChangedSignal ). In order to use property change events, you'll need to import OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Now you can pass in functions using [ OnChange \"PropertyName\" ] as the key. When the property is changed, your function will be called with the new value as the only argument. To demonstrate this, here we're printing the text in our TextBox whenever it changes: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Now, if you press 'Play' and start typing into the TextBox, you should see the TextBox's contents being printed to the output for each character you type: With that, you've covered everything there is to know about event and property change handlers! In later tutorials, this will be useful for responding to user input. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } }","title":"Handling Events"},{"location":"tutorials/instances/handling-events/#connecting-to-events","text":"Inside the code from above, you'll notice a TextButton. Let's try to connect to it's Activated event to detect mouse clicks. To help with this, New allows us to add event handlers on our instance directly. In order to use this feature, we need to import OnEvent from Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Now you can pass in event handling functions by using [ OnEvent \"EventName\" ] as the key. As an example, here we're connecting a function to our TextButton's Activated event: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), This works just like a regular :Connect - you'll recieve all the arguments from the event. Here, we're just printing them out for demonstration purposes. If you press 'Play' and click the button a few times, you should see something like this in the output: That's all there is to event handling! Fusion will manage the event connections for you automatically.","title":"Connecting to Events"},{"location":"tutorials/instances/handling-events/#responding-to-change","text":"In addition to regular events, you can listen to property change events (also known as: the events returned by GetPropertyChangedSignal ). In order to use property change events, you'll need to import OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Now you can pass in functions using [ OnChange \"PropertyName\" ] as the key. When the property is changed, your function will be called with the new value as the only argument. To demonstrate this, here we're printing the text in our TextBox whenever it changes: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Now, if you press 'Play' and start typing into the TextBox, you should see the TextBox's contents being printed to the output for each character you type: With that, you've covered everything there is to know about event and property change handlers! In later tutorials, this will be useful for responding to user input. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } }","title":"Responding to Change"},{"location":"tutorials/instances/hello-fusion/","text":"Now that we have Fusion up and running, let's learn how to create instances from a script quickly and neatly. Required code 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Instances from Code \u00b6 In Fusion, you create all of your UI instances from code. That might sound counterproductive, but it will soon allow you to easily reuse your UI components and leverage powerful tools for connecting your UI and game scripts together. To make the experience more pleasant, Fusion introduces an alternative to Instance.new which lets you construct entire instances in one go - called the New function. Here's an example code snippet using New - you can compare it to Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note You don't need parentheses () for New - just type the class name and properties like we did above. In the above code snippet, the New function: creates a new part gives it a position, size and colour parents it to the workspace returns the part, so it can be stored in myPart The New function has many more features built in, which you'll use later, but for now we'll just use it to set properties. Making A ScreenGui \u00b6 Let's use the New function to create a ScreenGui. We're going to put it in our PlayerGui , so we need to import the Players service: 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) We'll also need to import New from Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Now, we can use the New function like we did in the snippet above. We want to create a ScreenGui with these properties: a name of \"MyFirstGui\" ResetOnSpawn disabled the ZIndexBehavior set to Sibling parented to our PlayerGui What do these properties do? A name makes it easier to find our UI in the Explorer. Disabling ResetOnSpawn stops Roblox destroying our UI after we respawn. ZIndexBehavior is mostly preference, but it changes how UI is arranged by depth . Parenting it to the PlayerGui makes our UI visible on-screen. The following code snippet does all of this for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" } If you press 'Play', you should see that a ScreenGui has appeared in your PlayerGui, with all of the properties we've set: Hopefully you're getting comfortable with this syntax - we'll expand on it in the next section. Adding a Child \u00b6 Let's now add a TextLabel with a message and parent it to our ScreenGui . To help with this, the New function lets us add children directly to our instance. In order to use this feature, we first need to import Children from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Now, we can make any instance a child of our ScreenGui - just pass it in using [ Children ] as the key. For example, here we're creating our TextLabel, and adding it as a child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } If you press 'Play' now, you should see a TextLabel in the centre of your screen: Multiple Children \u00b6 You can add more than one instance - Children supports arrays of instances. If we wanted multiple TextLabels, we can create an array to hold our children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } } Now, we can add another TextLabel to the array, and it will also be parented: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } } If you press 'Play', you should see both TextLabels appear: Congratulations - you've now learned how to create simple instances with Fusion! Over the course of the next few tutorials, you'll see this syntax being used a lot, so you'll have some time to get used to it. It's important to understand the basics of the New function, as it's used throughout almost all Fusion code. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } }","title":"Hello, Fusion!"},{"location":"tutorials/instances/hello-fusion/#instances-from-code","text":"In Fusion, you create all of your UI instances from code. That might sound counterproductive, but it will soon allow you to easily reuse your UI components and leverage powerful tools for connecting your UI and game scripts together. To make the experience more pleasant, Fusion introduces an alternative to Instance.new which lets you construct entire instances in one go - called the New function. Here's an example code snippet using New - you can compare it to Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note You don't need parentheses () for New - just type the class name and properties like we did above. In the above code snippet, the New function: creates a new part gives it a position, size and colour parents it to the workspace returns the part, so it can be stored in myPart The New function has many more features built in, which you'll use later, but for now we'll just use it to set properties.","title":"Instances from Code"},{"location":"tutorials/instances/hello-fusion/#making-a-screengui","text":"Let's use the New function to create a ScreenGui. We're going to put it in our PlayerGui , so we need to import the Players service: 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) We'll also need to import New from Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Now, we can use the New function like we did in the snippet above. We want to create a ScreenGui with these properties: a name of \"MyFirstGui\" ResetOnSpawn disabled the ZIndexBehavior set to Sibling parented to our PlayerGui What do these properties do? A name makes it easier to find our UI in the Explorer. Disabling ResetOnSpawn stops Roblox destroying our UI after we respawn. ZIndexBehavior is mostly preference, but it changes how UI is arranged by depth . Parenting it to the PlayerGui makes our UI visible on-screen. The following code snippet does all of this for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" } If you press 'Play', you should see that a ScreenGui has appeared in your PlayerGui, with all of the properties we've set: Hopefully you're getting comfortable with this syntax - we'll expand on it in the next section.","title":"Making A ScreenGui"},{"location":"tutorials/instances/hello-fusion/#adding-a-child","text":"Let's now add a TextLabel with a message and parent it to our ScreenGui . To help with this, the New function lets us add children directly to our instance. In order to use this feature, we first need to import Children from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Now, we can make any instance a child of our ScreenGui - just pass it in using [ Children ] as the key. For example, here we're creating our TextLabel, and adding it as a child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } If you press 'Play' now, you should see a TextLabel in the centre of your screen:","title":"Adding a Child"},{"location":"tutorials/instances/hello-fusion/#multiple-children","text":"You can add more than one instance - Children supports arrays of instances. If we wanted multiple TextLabels, we can create an array to hold our children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } } Now, we can add another TextLabel to the array, and it will also be parented: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } } If you press 'Play', you should see both TextLabels appear: Congratulations - you've now learned how to create simple instances with Fusion! Over the course of the next few tutorials, you'll see this syntax being used a lot, so you'll have some time to get used to it. It's important to understand the basics of the New function, as it's used throughout almost all Fusion code. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } }","title":"Multiple Children"}]}